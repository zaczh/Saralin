<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, user-scalable=no, maximum-scale=1" >
<meta http-equiv="Cache-control" content="no-cache" >
<meta name="referrer" content="no-referrer" />
<title>${TITLE}</title>

<script type="text/javascript">
'use strict';

var callbackIndex = -1;
var callbackList = [];

function runCallbackFuncAtIndex(index, param) {
    var func = callbackList[index];
    if (typeof(func) == 'function') {
        var arr = Array.prototype.slice.call(arguments);
        arr.shift(1);
        func(arr);
    }
}

function reloadHTMLImgTags(url, to) {
    var elements = document.getElementsByTagName('img');
    Array.prototype.forEach.call(elements, function(e) {
         if (e.src == url) {
                                 if (to) {
                                    e.src = to;
                                 } else {
                                    // load failed
                                    log("img load failed url: " + url);
                                 }
         }
     });
        
}

function submitPollForm(e) {
    // on form submission, prevent default
     e.preventDefault();
     
     var form = e.target;
              
      // construct a FormData object, which fires the formdata event
      let formData = new FormData(form);
      var action = form.action;
    
      var object = {};
      formData.forEach((value, key) => {object[key] = value});
      var json = JSON.stringify(object);
      
      window.webkit.messageHandlers.page.postMessage({'action':'submit','data':{'formData':json,'formAction':action}});
}

function handleRadioStateChange(e) {
    var f = e.target;
    while (f != null && f.nodeName != 'FORM') {
        f = f.parentElement;
    };
    
    var rl = f.querySelectorAll("input");
    var legend = f.querySelector("legend");
    var checkLimit = legend.getAttribute("name");
    var checkedCount = 0;
    Array.prototype.forEach.call(rl, function(el){
                                 if (el.checked) {
                                     checkedCount++;
                                 }
                                 });
    
    if (e.target.checked) {
        if (checkedCount > checkLimit) {
            e.target.checked = false;
        }
    }
    
    var button = f.querySelector("button");
    if (button) {
        button.disabled = checkedCount == 0;
    }
}

function reloadCSS() {
    var link = document.head.getElementsByTagName("link")[0];
    var href = link.href.split("?")[0] + "?t=" + Date.now();
    href = href.split("/").reverse()[0];
    link.href = href;
}

// FIX: wired compatibility issue of safari
function getScrollTop() {
    return document.documentElement.scrollTop || document.body.scrollTop;
}

function setScrollTop(newValue) {
    document.documentElement.scrollTop = newValue;
    document.body.scrollTop = newValue;
}

function flashElement(el) {
    if (el == null) {
        return;
    }
    
    var oldClass = el.className;
    el.className = 'flash ' + oldClass;
    el.addEventListener("animationend", function(){
                       el.className = oldClass;
                       }, true);
}

function getCurrentFloor() {
    var width = window.innerWidth || document.documentElement.clientWidth;
    var el = document.elementFromPoint(width * 0.5, 20);
    if (el == null) {
        return "1";
    }
    
    while (el != null && el.className != 'post_wrapper') {
        el = el.parentElement;
    };
    
    if (el == null) {
        return "1";
    }
    
    var floor = el.querySelector('span.xg1 em').textContent;
    if (floor == null) {
        return "1";
    }
    
    return floor;
}

function getCurrentFloorTid() {
    var width = window.innerWidth || document.documentElement.clientWidth;
    var el = document.elementFromPoint(width * 0.5, 20);
    if (el == null) {
        return "1";
    }
    
    while (el != null && el.className != 'post_wrapper') {
        el = el.parentElement;
    };
    
    if (el == null) {
        return null;
    }
    
    return el.id.substr(3);
}

function scrollToFloor(floor) {
    Array.prototype.forEach.call(document.querySelectorAll('div.floor span.xg1 em'), function(el){
                                 if (el.textContent == floor) {
                                        var wrapper = el.parentElement;
                                        while(wrapper.className != 'post_wrapper') {
                                            wrapper = wrapper.parentElement;
                                        }
                                       if (wrapper != null ) {
                                         wrapper.scrollIntoView(true);
                                       }
                                 }
                                 });
}

function onImgLoadError(source){
    log("img load failed url: " + source.src);
    source.src = "${AVATAR_PLACEHOLDER_BASE64}";
    source.onerror = null;
}

function log(args) {
   window.webkit.messageHandlers.log.postMessage(args);
}

window.onerror = function (msg, url, lineNo, columnNo, error) {
    log({'msg':msg, 'url':url, 'line':lineNo, 'column':columnNo, 'error':error});
    return false;
};

var isInitialUpLoad = false;
var isInitialDownLoad = false;

var isLoadingMoreData = false;
var isAllDataLoaded = false;

var isLoadingMoreDataUpward = false;
var isAllDataLoadedUpward = false;

var touchendHandler = null;
var isTouching = false;

function clearBeforeReloading() {
    isLoadingMoreData = false;
    isAllDataLoaded = false;
    isLoadingMoreDataUpward = false;
    isAllDataLoadedUpward = false;
}

//this script is for lazy-loading images
function isElementInViewport (el) {
    var rect = el.getBoundingClientRect();
    return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
}

document.addEventListener("DOMContentLoaded", function(event) {
                          isInitialUpLoad = true;
                          isInitialDownLoad = true;
                          loadMoreUpward();
                          loadMoreDownward();
                          updateTime();
                          window.webkit.messageHandlers.webdata.postMessage({'floor':getCurrentFloor()});
                          });

function hideUpLoadingIndicator() {
    var footer=document.getElementById('up-loading');
    if(footer){
        if (footer.style.display != "none") {
            footer.style.display="none";
        }
    }
}

function showUpLoadingIndicator() {
    var footer=document.getElementById('up-loading');
    if (footer) {
        if (footer.style.display != "block") {
            footer.style.display="block";
        }
    }
}

function hideUpRetryDiv() {
    var footer=document.getElementById('up-load-more-retry');
    if(footer){
        if (footer.style.display != "none") {
            footer.style.display="none";
        }
    }
}

function showUpRetryDiv() {
    var footer=document.getElementById('up-load-more-retry');
    if (footer) {
        if (footer.style.display != "block") {
            footer.style.display="block";
        }
    }
}

function hideDownLoadingIndicator() {
    var footer=document.getElementById('down-loading');
    if (footer) {
        if (footer.style.display != "none") {
            footer.style.display="none";
        }
    }
}

function showDownLoadingIndicator() {
    var footer=document.getElementById('down-loading');
    if (footer) {
        if (footer.style.display != "block") {
            footer.style.display="block";
        }
    }
}

function hideDownRetryDiv() {
    var footer=document.getElementById('down-load-more-retry');
    if(footer){
        if (footer.style.display != "none") {
            footer.style.display="none";
        }
    }
}

function showDownRetryDiv() {
    var footer=document.getElementById('down-load-more-retry');
    if (footer) {
        if (footer.style.display != "block") {
            footer.style.display="block";
        }
    }
}

function loadMoreUpward() {
    if (isLoadingMoreDataUpward) {
        return;
    }
    isLoadingMoreDataUpward = true;
    
    if (!isInitialUpLoad) {
        showUpLoadingIndicator();
    }

    callbackList[++callbackIndex] = function(param) {
        var failed = param[0];
        var noMoreData = param[1];
        var content = param[2];
        
        if (isInitialUpLoad) {
            isInitialUpLoad = false;
        }
        
        if (failed) {
            hideUpLoadingIndicator();
            showUpRetryDiv();
            log("loadMoreUpward failed");
            return;
        }
        
        if (noMoreData) {
            hideUpLoadingIndicator();
            isLoadingMoreDataUpward=false;
            isAllDataLoadedUpward=true;
            return;
        }

        touchendHandler = function () {
            var oldScrollTop = getScrollTop();
            var oldHeight = document.body.scrollHeight;
            var div=document.createElement('div');
            div.innerHTML=content;
            var wp=document.getElementsByClassName("wp")[0];
            while(div.childElementCount>0) {
                wp.insertBefore(div.children[div.childElementCount-1], wp.firstElementChild);
            }
            updateTime();
            var newScrollTop = getScrollTop();
            var newHeight = document.body.scrollHeight;
            setScrollTop(oldScrollTop + newHeight - oldHeight);
            isLoadingMoreDataUpward=false;
        };

        if (!isTouching) {
            touchendHandler();
            touchendHandler = null;
        }
    };
    window.webkit.messageHandlers.threadloadmore.postMessage({'downward':false,'callbackIndex':callbackIndex});
}

function appendPostListContent(content) {
    var div=document.createElement('div');
    div.innerHTML=content;
    var wp = document.getElementsByClassName("wp")[0];
    while(div.childElementCount > 0) {
        wp.appendChild(div.children[0]);
    }
    updateTime();
}

function loadMoreDownward() {
    if (isLoadingMoreData) {
        return;
    }
    isLoadingMoreData = true;
    if (!isInitialDownLoad) {
        showDownLoadingIndicator();
    }

    callbackList[++callbackIndex] = function(param) {
        var failed = param[0];
        var noMoreData = param[1];
        var content = param[2];
        
        if (isInitialDownLoad) {
            isInitialDownLoad = false;
        }
        
        if (failed) {
            hideDownLoadingIndicator();
            showDownRetryDiv();
            log("loadMoreDownward failed");
            return;
        }
        
        if (noMoreData) {
            hideDownLoadingIndicator();
            isLoadingMoreData=false;
            isAllDataLoaded=true;
            return;
        }

        var div=document.createElement('div');
        div.innerHTML=content;
        var wp = document.getElementsByClassName("wp")[0];
        while(div.childElementCount > 0) {
            wp.appendChild(div.children[0]);
        }
        updateTime();
        isLoadingMoreData=false;
    };

    window.webkit.messageHandlers.threadloadmore.postMessage({'downward':true,'callbackIndex':callbackIndex});
}

document.addEventListener('touchstart', function (event) {
    isTouching = true;
});

document.addEventListener('touchend', function (event) {
    isTouching = false;
    if (touchendHandler != null && typeof(touchendHandler) == "function") {
        touchendHandler();
        touchendHandler = null;
    }
});

var scrollPosition = 0;
document.addEventListener('scroll', function (event) {
    window.webkit.messageHandlers.webdata.postMessage({'floor':getCurrentFloor()});
    var lastScrollPosition = scrollPosition;
    scrollPosition = getScrollTop();

    if (scrollPosition < lastScrollPosition) {
        if (getScrollTop() < 300) {
            if (isAllDataLoadedUpward) {
                hideUpLoadingIndicator();
                return;
            }
            loadMoreUpward();
        }
    } else {
        if (document.body.scrollHeight - 300 <= getScrollTop() + window.innerHeight) {
            if (isAllDataLoaded) {
                hideDownLoadingIndicator();
                return;
            }
            loadMoreDownward();
        }
    }
});

var intersectionObserver = null;
function setupMutationObserver() {
    // Select the node that will be observed for mutations
    const targetNode = document.body

    log("setupMutationObserver");

    // Options for the observer (which mutations to observe)
    const config = { attributes: false, childList: true, subtree: true };

    // Callback function to execute when mutations are observed
    const callback = function(mutationsList, observer) {
        // Use traditional 'for loops' for IE 11
        for(let mutation of mutationsList) {
            if (mutation.type === 'childList') {
                var images = document.querySelectorAll("img[data-src]");
                [].forEach.call(images, function (item) {
                    intersectionObserver.observe(item);
                });
            }
        }
    };

    const observer = new MutationObserver(callback);
    observer.observe(targetNode, config);
}

let intersectionCallback = (entries, observer) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      let elem = entry.target;
      elem.setAttribute("src", elem.getAttribute("data-src"));
      elem.removeAttribute("data-src");
      observer.unobserve(elem);
    }
  });
};

if (typeof IntersectionObserver == 'function') {
    intersectionObserver = new IntersectionObserver(intersectionCallback, {
      root: null,
      threshold: 0
    });
}

if (intersectionObserver == null) {
    // these handlers will be removed once the images have loaded
    window.addEventListener("DOMContentLoaded", lazyLoadImages);
    window.addEventListener("load", lazyLoadImages);
    window.addEventListener("resize", lazyLoadImages);
    window.addEventListener("scroll", lazyLoadImages);
} else {
    window.addEventListener("DOMContentLoaded", (event) => {
      var images = document.querySelectorAll("img[data-src]");
      [].forEach.call(images, function (item) {
          intersectionObserver.observe(item);
      });
      setupMutationObserver();
    }, false);
}

function lazyLoadImages() {
    var images = document.querySelectorAll("img[data-src]");
    // load images that have entered the viewport
    [].forEach.call(images, function (item) {
                        if (isElementInViewport(item)) {
                            item.setAttribute("src",item.getAttribute("data-src"));
                            item.removeAttribute("data-src");
                        }
                    });
}

//FROM: http://stackoverflow.com/a/3177838
function timeSince(date) {
    var seconds = Math.floor((new Date() - date) / 1000);
    var interval = Math.floor(seconds / 31536000);
    if (interval >= 1) {
        return interval + "年前";
    }
    interval = Math.floor(seconds / 2592000);
    if (interval >= 1) {
        return interval + "个月前";
    }
    interval = Math.floor(seconds / 86400);
    if (interval >= 1) {
        return interval + "天前";
    }
    interval = Math.floor(seconds / 3600);
    if (interval >= 1) {
        return interval + "小时前";
    }
    interval = Math.floor(seconds / 60);
    if (interval >= 1) {
        return interval + "分钟前";
    }
    return Math.floor(seconds) + "秒前";
}

function updateTime(){
    var currentTime = new Date()
    var timeLabels = document.getElementsByClassName('post_time');
    Array.prototype.forEach.call(timeLabels, function(timeLabel){
                                 var ds = timeLabel.textContent;
                                 //Example: "2016-12-15 18:33"
                                 var year=ds.split("-")[0];
                                 var month =ds.split("-")[1];
                                 var day=(ds.split("-")[2]).split(" ")[0];
                                 var hour=(ds.split(" ")[1]).split(":")[0];
                                 var minute=(ds.split(" ")[1]).split(":")[1];
                                 var d = new Date(parseInt(year),parseInt(month)-1,parseInt(day),parseInt(hour),parseInt(minute),0);
      d.setUTCHours(d.getUTCHours());
      var timeDisplay = timeLabel.nextElementSibling;
      timeDisplay.innerHTML = timeSince(d) + " " + hour + ":" + minute;
    });
}
setInterval(updateTime, 30000);

</script>

<link rel="stylesheet" type="text/css" href="base.css?t=${CSS_FILE_TIMESTAMP}">
</head>
<body>
    <div class="content_body">
    <div class="post_title">
        <div class="bm_h">
${TITLE}
</div>
<div class="bm_inf"><font class="xg1">看${VIEW_COUNT}&nbsp;回${REPLY_COUNT}</font></div>
</div>
    <div class="loadMoreRetry" id="up-load-more-retry" onclick="hideUpRetryDiv(); hideUpLoadingIndicator(); isLoadingMoreDataUpward=false; loadMoreUpward();" style="display: none"><span>加载失败，点击重试</span></div>

    <div class="loading" id="up-loading" style="display: none">
        <div>
            <div class="activityIndicator"></div>
        </div>
    </div>
    
    <div class="wp">
